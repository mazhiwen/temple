{"version":3,"file":"immer.umd.js","sources":["../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["export const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    if (value.__proto__ === undefined)\n        return Object.assign(Object.create(null), value)\n    return Object.assign({}, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            return finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state\n            )\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) copy[prop] = finalize(value)\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    freeze,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Don't even try this...\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\n\nfunction createState(parent, base) {\n    return {\n        modified: false,\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop) ? state.proxies : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does currently not support defining properties on draft objects\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base) {\n    const state = createState(parentState, base)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer) {\n    const previousProxies = proxies\n    proxies = []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result = finalize(rootProxy)\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = returnValue\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    freeze,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process?\"\n        )\n}\n\n// this sounds very expensive, but actually it is not that extensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChanges() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    return state.proxy.length !== state.base.length\n}\n\nexport function produceEs5(baseState, producer) {\n    const prevStates = states\n    states = []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        // find and mark all changes (for parts not done yet)\n        // TODO: store states by depth, to be able guarantee processing leaves first\n        markChanges()\n        let result = finalize(rootProxy)\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = returnValue\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {setAutoFreeze, setUseProxies} from \"./common\"\n\nimport {isProxyable, getUseProxies} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport default function produce(baseState, producer) {\n    // curried invocation\n    if (arguments.length === 1) {\n        const producer = baseState\n        // prettier-ignore\n        if (typeof producer !== \"function\") throw new Error(\"if produce is called with 1 argument, the first argument should be a function\")\n        return function() {\n            const args = arguments\n            return produce(args[0], draft => {\n                args[0] = draft // blegh!\n                return producer.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (arguments.length !== 2)  throw new Error(\"produce expects 1 or 2 arguments, got \" + arguments.length)\n        if (typeof producer !== \"function\") throw new Error(\"the second argument to produce should be a function\")\n    }\n\n    // it state is a primitive, don't bother proxying at all and just return whatever the producer returns on that value\n    if (typeof baseState !== \"object\" || baseState === null)\n        return producer(baseState)\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return getUseProxies()\n        ? produceProxy(baseState, producer)\n        : produceEs5(baseState, producer)\n}\n"],"names":["PROXY_STATE","Symbol","RETURNED_AND_MODIFIED_ERROR","autoFreeze","process","env","NODE_ENV","name","useProxies","Proxy","isProxy","value","isProxyable","Array","isArray","proto","Object","getPrototypeOf","prototype","freeze","shallowCopy","slice","undefined","__proto__","assign","create","each","cb","i","length","key","has","thing","prop","hasOwnProperty","call","finalize","base","state","modified","finalized","copy","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","createProxy","target","source","Reflect","ownKeys","owner","descriptor","getOwnPropertyDescriptor","configurable","Error","arrayTraps","markChanged","parentState","proxy","revocable","push","fn","arguments","apply","this","descriptors","states","hasCopy","prepareCopy","defineProperty","finalizing","get","assertUnfinished","finished","produceEs5","baseState","producer","prevStates","rootProxy","returnValue","_","baseKeys","keys","objA","objB","keysA","keysB","shallowEqual","result","produce","args","draft","previousProxies","p","revoke","produceProxy","enableAutoFreeze"],"mappings":"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"}